---
description: 整数リテラルと実数リテラルは、どちらも型および乗数サフィックスを持つことができます。
Locale: en-US
ms.date: 04/12/2019
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_numeric_literals?view=powershell-7&WT.mc_id=ps-gethelp
schema: 2.0.0
title: 数値リテラルについて
ms.openlocfilehash: f9d23a37c06c8285c23328ea8ddcebf8d6caae9e
ms.sourcegitcommit: 39c2a697228276d5dae39e540995fa479c2b5f39
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/05/2020
ms.locfileid: "93354730"
---
# <a name="about-numeric-literals"></a>数値リテラルについて

数値リテラルには、整数と実数の2種類があります。 どちらも、型と乗数のサフィックスを持つことができます。

## <a name="integer-literals"></a>整数リテラル

整数リテラルは、10進数、16進数、またはバイナリ表記で記述できます。
16進数リテラルにはプレフィックスが付き `0x` 、バイナリリテラルには、 `0b` 10 進数と区別するためのプレフィックスが付きます。

整数リテラルには、型サフィックスと乗数サフィックスを含めることができます。

| サフィックス |            意味             |          メモ           |
| ------ | ------------------------------ | ----------------------- |
| ○      | 符号付きバイトデータ型          | PowerShell 6.2 で追加 |
| uy     | unsigned byte データ型        | PowerShell 6.2 で追加 |
| s      | short データ型                | PowerShell 6.2 で追加 |
| us     | unsigned short データ型       | PowerShell 6.2 で追加 |
| l      | long データ型                 |                         |
| u      | unsigned int または long データ型 | PowerShell 6.2 で追加 |
| ul     | unsigned long データ型        | PowerShell 6.2 で追加 |
| n      | BigInteger データ型           | PowerShell 7.0 で追加 |
| kb     | キロバイト乗数            |                         |
| mb     | メガバイト乗数            |                         |
| 8gb     | ギガバイト乗数            |                         |
| 単位     | テラバイト乗数            |                         |
| pb     | ペタバイト乗数            |                         |

整数リテラルの型は、その値、型のサフィックス、および数値乗数のサフィックスによって決定されます。

型サフィックスのない整数リテラルの場合:

- 値を型で表すことができる場合 `[int]` は。それが型である場合は。
- それ以外の場合、値を型で表すことができる場合は、それ以外の場合は `[long]` 型です。
- それ以外の場合、値を型で表すことができる場合は、それ以外の場合は `[decimal]` 型です。
- それ以外の場合は、型によって表され `[double]` ます。

型サフィックスを持つ整数リテラルの場合:

- 型のサフィックスがで、 `u` 値を型で表すことができる場合、 `[uint]` 型はになり `[uint]` ます。
- 型のサフィックスがで、 `u` 値を型で表すことができる場合、 `[ulong]` 型はになり `[ulong]` ます。
- 指定された型で値を表すことができる場合は、その型になります。
- それ以外の場合は、そのリテラルの形式が正しくありません。

## <a name="real-literals"></a>実数リテラル

実際のリテラルは、10進表記でのみ記述できます。 この表記法では、小数点の後に指数部を使用した小数値と指数表記を含めることができます。

指数部には、"e" の後に省略可能な符号 (+/-) と指数を表す数値が含まれます。 たとえば、リテラル値は `1e2` 数値100と同じです。

実際のリテラルは、型サフィックスと乗数サフィックスを持つことができます。

| サフィックス |       意味       |
| ------ | ------------------- |
| d      | decimal データ型   |
| kb     | キロバイト乗数 |
| mb     | メガバイト乗数 |
| 8gb     | ギガバイト乗数 |
| 単位     | テラバイト乗数 |
| pb     | ペタバイト乗数 |

実数リテラルには、double と decimal の2種類があります。 これらは、それぞれ、decimal 型のサフィックスによって、個別に存在するかどうかが示されます。 PowerShell では、値のリテラル表現はサポートされていません `[float]` 。 Double 実数リテラルには型があり `[double]` ます。 10進数の実数リテラルには型があり `[decimal]` ます。
10進数の実数リテラルの小数部の末尾の0は有意です。

実数リテラルの指数部の数字の値が、 `[double]` サポートされる最小値よりも小さい場合、その `[double]` 実数リテラルの値は0になります。 実数リテラルの指数部の数字の値が、 `[decimal]` サポートされている最小値よりも小さい場合、そのリテラルの形式が正しくありません。 または実数リテラルの指数部の数字の値 `[double]` `[decimal]` が、サポートされている最大値を超えている場合、そのリテラルの形式が正しくありません。

> [!NOTE]
> この構文では、2つの実数リテラルに long 型のサフィックスを付けることができます。
> PowerShell では、このケースは、値が型で表される整数リテラルとして扱われ `[long]` ます。 この機能は、以前のバージョンの PowerShell との下位互換性のために残されています。 ただし、プログラマはこの形式の整数リテラルを使用しないことをお勧めします。これは、リテラルの実際の値を簡単に隠すことができるためです。 たとえば、の値 `1.2L` が1で、値が `1.2345e1L` 12 で、 `1.2345e-5L` 値が0である場合、そのいずれもすぐにはわかりません。

## <a name="numeric-multipliers"></a>数値乗数

便宜上、整数と実数のリテラルには数値乗数を含めることができます。これは、一般的に使用される2の累乗の1つを示します。 数値の乗数は、大文字または小文字の任意の組み合わせで記述できます。

乗数サフィックスは任意の型サフィックスと組み合わせて使用できますが、型サフィックスの後に存在する必要があります。 たとえば、リテラルの `100gbL` 形式が正しくありませんが、リテラルは `100Lgb` 有効です。

乗数によって指定された数値型の有効な値を超える値が作成されると、リテラルの形式が正しくありません。 たとえば、リテラルは、 `1usgb` `1gb` `[ushort]` サフィックスによって指定された型で許可されている値よりも大きいため、形式が正しくあり `us` ません。

### <a name="multiplier-examples"></a>乗数の例

```
PS> 1kb
1024

PS> 1.30Dmb
1363148.80

PS> 0x10Gb
17179869184

PS> 1.4e23tb
1.5393162788864E+35

PS> 0x12Lpb
20266198323167232
```

## <a name="numeric-type-accelerators"></a>数値型アクセラレータ

PowerShell では、次の種類のアクセラレータがサポートされています。

| アクセラレータ |         メモ         |           [説明]            |
| ----------- | -------------------- | -------------------------------- |
| `[byte]`    |                      | バイト (符号なし)                  |
| `[sbyte]`   |                      | バイト (符号付き)                    |
| `[Int16]`   |                      | 16 ビット整数                   |
| `[short]`   | の別名 `[int16]`  | 16 ビット整数                   |
| `[UInt16]`  |                      | 16ビット整数 (符号なし)        |
| `[ushort]`  | の別名 `[uint16]` | 16ビット整数 (符号なし)        |
| `[Int32]`   |                      | 32-bit integer                   |
| `[int]`     | の別名 `[int32]`  | 32-bit integer                   |
| `[UInt32]`  |                      | 32ビット整数 (符号なし)        |
| `[uint]`    | の別名 `[uint32]` | 32ビット整数 (符号なし)        |
| `[Int64]`   |                      | 64 ビット整数                   |
| `[long]`    | の別名 `[int64]`  | 64 ビット整数                   |
| `[UInt64]`  |                      | 64ビット整数 (符号なし)        |
| `[ulong]`   | の別名 `[uint64]` | 64ビット整数 (符号なし)        |
| `[bigint]`  |                      | 「 [BigInteger Struct][bigint] 」を参照してください。  |
| `[single]`  |                      | 単精度浮動小数点  |
| `[float]`   | の別名 `[single]` | 単精度浮動小数点  |
| `[double]`  |                      | 倍精度浮動小数点  |
| `[decimal]` |                      | 128ビット浮動小数点           |

> [!NOTE]
> PowerShell 6.2 では、、、、の各型アクセラレータが追加されました。 `[short]` `[ushort]` `[uint]` `[ulong]`

## <a name="examples"></a>例

次の表は、数値リテラルの例をいくつか示し、その型と値を示しています。

|   Number     |  Type      |    値     |
| -----------: | ---------- | -----------: |
|         100  | Int32      |          100 |
|        100u  | UInt32     |          100 |
|        100D  | Decimal    |          100 |
|        100l  | Int64      |          100 |
|       100uL  | UInt64     |          100 |
|       100us  | UInt16     |          100 |
|       100uy  | Byte       |          100 |
|        100y  | SByte      |          100 |
|         1e2  | Double     |          100 |
|        e2  | Double     |          100 |
|       0x1e2  | Int32      |          482 |
|      0x1e2L  | Int64      |          482 |
|      0x1e2D  | Int32      |         7725 |
|        482D  | Decimal    |          482 |
|       48 gb  | Int64      | 517543559168 |
|       482ngb | BigInteger | 517543559168 |
|    0x1e2lgb  | Int64      | 517543559168 |
|   0b1011011  | Int32      |           91 |
|  ~  | Int32      |           -1 |
| -0xFFFFFFFF  | Int32      |            1 |
| 0xFFFFFFFFu  | UInt32     |   4294967295 |

### <a name="working-with-binary-or-hexadecimal-numbers"></a>バイナリまたは16進数の使用

極端に大きいバイナリまたは16進数のリテラルは、 `[bigint]` サフィックスが指定されている場合にのみ、解析が失敗するのではなく、as を返すことができ `n` ます。 ただし、符号ビットは引き続き範囲を超えてい `[decimal]` ます。

- バイナリ文字列が8ビット長の倍数である場合、最大ビットは符号ビットとして扱われます。
- 8の倍数である16進数の文字列に、8以上の最初の桁が含まれている場合、数字は負の値として扱われます。

バイナリリテラルと16進数リテラルに符号なしサフィックスを指定すると、符号ビットが無視されます。 たとえば、はを `0xFFFFFFFF` 返し `-1` ますが、は `0xFFFFFFFFu` 4294967295 のを返し `[uint]::MaxValue` ます。

リテラルにプレフィックスとしてを指定する `0` と、これは無視され、符号なしとして扱われます。
例: `0b011111111`。 これは、 `[bigint]` `u` とのサフィックスを組み合わせることができないため、範囲内のリテラルを使用する場合に必要になることがあり `n` ます。

プレフィックスを使用して、バイナリリテラルと16進リテラルを否定することもでき `-` ます。 符号ビットが許可されるため、これにより正の数値が返される場合があります。

符号ビットは、BigInteger の数字で受け入れられます。

- BigInteger-サフィックス16は、符号ビットとして8文字の倍数であるリテラルの上位ビットを処理します。 長さには、 `0x` プレフィックスまたはサフィックスは含まれません。
- BigInteger バイナリでは、96と128文字の符号ビット、およびの後の8文字ごとに16進数を受け取ります。

### <a name="commands-that-look-like-numeric-literals"></a>数値リテラルのようなコマンド

有効な数値リテラルのようなコマンドは、呼び出し演算子 () を使用して実行する必要があり `&` ます。そうしないと、数値として解釈されます。 のような有効な構文を使用した正しくないリテラルで `1usgb` は、次のエラーが発生します。

```
PS> 1usgb
At line:1 char:6
+ 1usgb
+      ~
The numeric constant 1usgb is not valid.
+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
+ FullyQualifiedErrorId : BadNumericConstant
```

ただし、のような無効な構文を使用した正しく `1gbus` ないリテラルは、標準のベア文字列として解釈され、コマンドが呼び出されるコンテキストで有効なコマンド名として解釈できます。

### <a name="access-properties-and-methods-of-numeric-objects"></a>数値オブジェクトのプロパティとメソッドへのアクセス

数値リテラルのメンバーにアクセスするには、リテラルをかっこで囲む必要がある場合があります。

- リテラルに小数点がありません
- リテラルの小数点の後に数字がありません。
- リテラルにサフィックスがありません

たとえば、次の例では失敗します。

```
PS> 2.GetType().Name
At line:1 char:11
+ 2.GetType().Name
+           ~
An expression was expected after '('.
+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
+ FullyQualifiedErrorId : ExpectedExpression
```

次の例は動作します。

```
PS> 2uL.GetType().Name
UInt64
PS> 1.234.GetType().Name
Double
PS> (2).GetType().Name
Int32
```

最初の2つの例では、リテラル値をかっこで囲まずに使用します。これは、PowerShell パーサーが数値リテラルの終了位置と **GetType** メソッドの開始位置を判別できるためです。

## <a name="how-powershell-parses-numeric-literals"></a>PowerShell で数値リテラルを解析する方法

PowerShell v1.0 では、新しい機能を有効にするために、数値リテラルの解析方法が変更されました。

### <a name="parsing-real-numeric-literals"></a>実際の数値リテラルの解析

リテラルに小数点または e 表記が含まれている場合、リテラル文字列は実数を解析します。

- 小数点サフィックスがある場合は、に直接を指定し `[decimal]` ます。
- それ以外の場合は、として解析 `[Double]` し、値に乗数を適用します。 次に、型のサフィックスを確認し、適切な型へのキャストを試みます。
- 文字列に型のサフィックスがない場合は、として解析し `[Double]` ます。

### <a name="paring-integer-numeric-literals"></a>ペアリング整数の数値リテラル

整数型リテラルは、次の手順を使用して解析されます。

1. 基数の形式を決定する
   - バイナリ形式の場合は、をに解析 `[BigInteger]` します。
   - 16進数形式の場合 `[BigInteger]` は、値がまたはの範囲内にある場合に、特別なビヘイビアーを使用してを解析し、元のを保持し `[int]` `[long]` ます。
   - バイナリも16進数でもない場合は、をとして通常どおり解析 `[BigInteger]` します。
2. オーバーフローを発生させずに型の境界を適切にチェックするために、キャストを試行する前に乗数値を適用します。
3. 型のサフィックスを確認します。
   - 型の境界を確認し、その型への解析を試行します。
   - サフィックスが使用されていない場合、値は次の順序で境界チェックされます。その結果、最初に成功したテストで数値の型が決定されます。
     - `[int]`
     - `[long]`
     - `[decimal]` (基数10リテラルのみ)
     - `[double]` (基数10リテラルのみ)
   - 値が `[long]` 16 進数値と2進数の範囲外の場合、解析は失敗します。
   - 値が `[double]` 底10の数値の範囲外の場合、解析は失敗します。
   - リテラルをと `n` して解析するには、サフィックスを使用して、より高い値を明示的に記述する必要があり `BigInteger` ます。

### <a name="parsing-large-value-literals"></a>大きな値のリテラルの解析

以前は、より高い整数値は、他の型にキャストされる前に double として解析されていました。 その結果、より高い範囲で精度が低下します。 次に例を示します。

```
PS> [bigint]111111111111111111111111111111111111111111111111111111
111111111111111100905595216014112456735339620444667904
```

この問題を回避するには、値を文字列として書き込み、次のように変換する必要がありました。

```
PS> [bigint]'111111111111111111111111111111111111111111111111111111'
111111111111111111111111111111111111111111111111111111
```

PowerShell 7.0 では、サフィックスを使用する必要があり `N` ます。

```
PS> 111111111111111111111111111111111111111111111111111111n
111111111111111111111111111111111111111111111111111111
```

また、との間の値は、 `[ulong]::MaxValue` `[decimal]::MaxValue` `D` 精度を維持するために、小数点のサフィックスを使用して指定する必要があります。 サフィックスがない場合、これらの値は `[Double]` 実際の解析モードを使用して解析されます。

<!-- reference links -->
[bigint]: /dotnet/api/system.numerics.biginteger
