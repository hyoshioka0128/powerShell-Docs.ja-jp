---
ms.date: 07/09/2020
ms.topic: reference
title: 拡張型システムの概要
description: 拡張型システムの概要
ms.openlocfilehash: f4a789f779fa8a52f0fe524abff7ec3311e93b6c
ms.sourcegitcommit: ba7315a496986451cfc1296b659d73ea2373d3f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2020
ms.locfileid: "92655719"
---
# <a name="extended-type-system-overview"></a>拡張型システムの概要

PowerShell では、 **PSObject** オブジェクトを使用して、オブジェクトの型を2つの方法で拡張します。 最初に、 **PSObject** オブジェクトは、特定のオブジェクトの種類のさまざまなビューを表示する方法を提供します。 これは、オブジェクトの適用されたビューの表示と呼ばれます。 次に、 **PSObject** オブジェクトを使用して、既存のオブジェクトにメンバーを追加する方法を提供します。 また、既存のオブジェクト (ベースオブジェクトと呼ばれます) をラップすることによって、 **PSObject** オブジェクトは、スクリプトとコマンドレットの開発者がシェル内の .net オブジェクトを操作するために使用できる拡張型システムを提供します。

## <a name="cmdlet-and-script-development-issues"></a>コマンドレットとスクリプトの開発に関する問題

は、次の2つの基本的な問題を解決します。

まず、一部の .NET オブジェクトには、コマンドレット間のデータとして動作するために必要な既定の動作がありません。

- .NET オブジェクトの中には、"メタ" オブジェクト (WMI オブジェクト、ADO オブジェクト、XML オブジェクトなど) が含まれています。これらのオブジェクトには、メンバーが格納しているデータが記述されています。 ただし、スクリプト環境では、格納されているデータの説明ではなく、最も興味深いデータになります。 この問題を解決するには、基になる .NET オブジェクトを適合させるアダプターの概念を導入し、期待される既定のセマンティクスを持つようにします。
- 一部の .NET オブジェクトメンバーの名前が一貫していないか、パブリックメンバーのセットが不十分であるか、または機能が不十分です。 では、追加メンバーを使用して .NET オブジェクトを拡張する機能を導入することで、この問題を解決します。

2つ目の方法として、PowerShell スクリプト言語は、変数を特定の型で宣言する必要がないということ _ではあり_ ません。 つまり、スクリプト開発者が作成する変数は、本質的に _タイプレス_ です。 ただし、PowerShell システムは、結果の出力や並べ替えなどの基本的な操作のために、型名を使用することに依存しているので、"タイプドリブン" になります。

そのため、スクリプト開発者は、変数の1つの型を指定し、プロパティとメソッドを含む動的に型指定された "オブジェクト" のセットを構築し、型駆動型システムに参加させることができなければなりません。 この問題を解決するには、その型を動的に指定し、メンバーを動的に追加することができるスクリプト言語の共通オブジェクトを提供します。

根本的には、前述の問題を解決します。 **PSObject** オブジェクトは、スクリプト言語からのすべてのオブジェクトアクセスの基礎として機能し、コマンドレットの開発者に標準の抽象化を提供します。

### <a name="cmdlet-developers"></a>コマンドレットの開発者

コマンドレットの開発者には、次のサポートが用意されています。

- **PSObject** オブジェクトを使用して汎用的な方法でオブジェクトに対して動作する抽象化。 また、これらの抽象化を必要に応じてドリルダウンする機能も提供します。
- よく知られている拡張メンバーのセットを使用して、オブジェクトの種類に対する書式設定、並べ替え、シリアル化、およびその他のシステム操作の既定の動作を作成するための機構。
- 言語プリミティブオブジェクトを使用して、スクリプト言語と同じセマンティクスを使用して任意のオブジェクトに対して操作を実行することを意味します。
- は、ハッシュテーブルを動的に "型" にすることを意味します。これにより、システムの残りの部分が効果的に操作できるようになります。

### <a name="script-developers"></a>スクリプト開発者

スクリプト開発者には、次のサポートが用意されています。

- 同じ構文 () を使用して、基になるオブジェクト型を参照する機能 `$a.x` 。
- **PSObject** オブジェクトによって提供される抽象化の範囲を超えてアクセスする機能 (適用されるメンバーへのアクセス、ベースオブジェクト自体へのアクセスなど)。
- オブジェクトインスタンスまたは型の書式設定、並べ替え、シリアル化、およびその他の操作を制御する既知のメンバーを定義する機能。
- は、オブジェクトに特定の型として名前を付けて、その型ベースのメンバーの継承を制御することを意味します。
- 拡張メンバーを追加、削除、および変更する機能。
- 必要に応じて、 **PSObject** オブジェクト自体を操作する権限。

## <a name="the-psobject-class"></a>PSObject クラス

**PSObject** オブジェクトは、スクリプト言語からのすべてのオブジェクトアクセスの基礎であり、コマンドレットの開発者を対象とした標準の抽象化を提供します。 これには、基本オブジェクト (.NET オブジェクト) と、特定のオブジェクトインスタンスに存在する (特に拡張メンバー) すべてのインスタンスメンバー (同じ型の他のオブジェクトではありません) が含まれます。 **PSObject** オブジェクトは、ベースオブジェクトの型によっては、適合したメンバーおよび任意の型ベースの拡張メンバーへの暗黙的かつ明示的なアクセスを提供する場合もあります。

**PSObject** オブジェクトには、次のメカニズムが用意されています。

- 基底オブジェクトを使用するかどうかにかかわらず、 **PSObject** を構築する機能。
- 共通の参照アルゴリズムを使用して、構築された各 **PSObject** オブジェクトのすべてのメンバーにアクセスする機能と、必要に応じてそのアルゴリズムをオーバーライドする機能。
- 構築された **psobject** オブジェクトの型名を取得および設定する機能。これにより、スクリプトとコマンドレットは、基本オブジェクトの型に関係なく、同じ型名で類似した **psobject** オブジェクトを参照できます。

### <a name="how-to-construct-a-psobject"></a>PSObject を構築する方法

次の一覧では、 **PSObject** オブジェクトを作成する方法について説明します。

- **Psobject** #ctor コンストラクターを呼び出すと、PSCustomObject 基本オブジェクトを持つ新しい **PSObject** オブジェクトが作成されます。 この型の基本オブジェクトは、 **PSObject** オブジェクトに有効な基本オブジェクトがないことを示します。 ただし、この種類の base オブジェクトを持つ **PSObject** オブジェクトは、拡張メンバーを追加することによって、コマンドレットの開発者が役に立つプロパティバッグを提供します。

開発者は、オブジェクトの種類名を指定することもできます。これにより、このオブジェクトが、その拡張メンバーを同じ型名の他の **PSObject** オブジェクトと共有できるようになります。

- #Ctor (System.object) コンストラクターを呼び出すと、System.object 型の基底オブジェクトを持つ新しい **PSObject** オブジェクトが作成 **されます**。

  この場合、作成されたオブジェクトの型名は、基本オブジェクトの派生階層のコレクションです。 たとえば、ProcessInfo ベースオブジェクトを含む **PSObject** の型名には、次の名前が含まれます。

  - System.Diagnostics.Process
  - System.componentmodel
  - System.MarshalByRefObject
  - System.Object

- **PSObject** を呼び出しています。AsPSObject (System.object) メソッドは、指定されたオブジェクトに基づいて新しい **PSObject** オブジェクトを作成します。

  指定されたオブジェクトが System.object 型である場合は、指定されたオブジェクトが新しい **PSObject** オブジェクトのベースオブジェクトとして使用されます。 指定されたオブジェクトが既に **PSObject** オブジェクトである場合、指定されたオブジェクトはとして返されます。

### <a name="base-adapted-and-extended-members"></a>基本メンバー、適合メンバー、および拡張メンバー

概念的には、次の用語を使用して、ベースオブジェクトの元のメンバーと PowerShell によって追加されたメンバーの関係を示します。 **Psobject** オブジェクトによって使用される特定の種類のメンバーの詳細については、「 [psobject クラス](/dotnet/api/system.management.automation.psobject)」を参照してください。

#### <a name="base-object-members"></a>基本オブジェクトのメンバー

**PSObject** オブジェクトの構築時にベースオブジェクトが指定されている場合、基本オブジェクトのメンバーは、members プロパティを介して使用できます。

#### <a name="adapted-members"></a>適合したメンバー

基本オブジェクトがメタオブジェクトであり、その中に含まれるデータがプロパティによって "説明" されている汎用的な方法でデータを格納している場合は、を使用して、 **PSObject** オブジェクトの適用されたメンバーを介してデータに直接アクセスできるように、それらのオブジェクトをビューに適応させます。 適合したメンバーと基本オブジェクトのメンバーにアクセスするには、Members プロパティを使用します。

#### <a name="extended-members"></a>拡張メンバー

ベースオブジェクトから使用できるメンバー、または PowerShell によって作成された適用されるメンバーに加えて、 **PSObject** は、スクリプト環境で役立つ追加情報を使用して元の基本オブジェクトを拡張する拡張メンバーを定義することもあります。

たとえば、PowerShell によって提供されるすべてのコアコマンドレット (Get-Content コマンドレットや Set-Content コマンドレットなど) は、path パラメーターを受け取ります。 これらのコマンドレットおよび他のコマンドレットが異なる種類のオブジェクトに対して動作できるようにするには、それらのオブジェクトにパスメンバーを追加して、それらのすべてが共通の方法で情報を参照できるようにすることができます。 この拡張パスメンバーを使用すると、基底クラスにパスメンバーが含まれていない場合でも、これらのすべての型に対してコマンドレットを確実に動作させることができます。

拡張メンバー、適用されるメンバー、および基本オブジェクトのメンバーはすべて、Members プロパティを介してアクセスされます。
