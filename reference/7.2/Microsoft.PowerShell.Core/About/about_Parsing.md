---
description: PowerShell によるコマンドの解析方法について説明します。
Locale: en-US
ms.date: 09/14/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-7.2&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Parsing
ms.openlocfilehash: a5ce30b2ad9aff7dd8b54e7a62937013a61cd278
ms.sourcegitcommit: 95d41698c7a2450eeb70ef2fb6507fe7e6eff3b6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/17/2020
ms.locfileid: "99603250"
---
# <a name="about-parsing"></a>解析の概要

## <a name="short-description"></a>概要
PowerShell によるコマンドの解析方法について説明します。

## <a name="long-description"></a>詳細説明

コマンドプロンプトでコマンドを入力すると、PowerShell はコマンドテキストを _トークン_ と呼ばれる一連のセグメントに分割し、各トークンの解釈方法を決定します。

たとえば、次のように入力します。

```powershell
Write-Host book
```

PowerShell では、コマンドがとという2つのトークンに分割され、 `Write-Host` `book` 2 つの主要な解析モード (expression モードと argument モード) のいずれかを使用して各トークンが個別に解釈されます。

> [!NOTE]
> PowerShell によってコマンド入力が解析されるので、コマンド名をコマンドレットまたはネイティブの実行可能ファイルに解決しようとします。 コマンド名に完全に一致するものがない場合、PowerShell は `Get-` 既定の動詞としてコマンドの前に付加します。 たとえば、PowerShell はとしてを解析し `Process` `Get-Process` ます。 この機能は、次の理由で使用することはお勧めしません。
>
> - これは非効率的です。 これにより、PowerShell が複数回検索されます。
> - 同じ名前の外部プログラムが最初に解決されるため、目的のコマンドレットを実行することはできません。
> - `Get-Help``Get-Command`動詞のない名前は認識されません。

### <a name="expression-mode"></a>式モード

式モードは、スクリプト言語での値の操作に必要な結合式を使用することを目的としています。 式は PowerShell 構文の値の表現であり、単純型または複合型にすることができます。次に例を示します。

リテラル式は、値を直接表現したものです。 

```powershell
'hello', 32
```

変数式には、参照する変数の値が含まれます。 

```powershell
$x, $script:path
```
演算子は、評価のために他の式を結合します。 

```powershell
- 12, -not $Quiet, 3 + 7, $input.Length -gt 1
```

- _文字列リテラル_ は引用符で囲む必要があります。
- _数値_ は、エスケープされない限り、一連の文字としてではなく、数値として扱われます。
- _演算子_(やなどの、やなどの二項演算子を含む) `-` `-not` `+` `-gt` は演算子として解釈され、それぞれの引数 (オペランド) に対してそれぞれの操作を適用します。
- _属性および変換式_ は式として解析され、下位の式 (など) に適用され `[int] '7'` ます。
- _変数参照_ はその値に評価されますが、 _スプラッティング_ (事前パラメーターセットの貼り付け) は禁止されているため、パーサーエラーが発生します。
- それ以外のものは、呼び出されるコマンドとして扱われます。

### <a name="argument-mode"></a>引数モード

解析時に、PowerShell は最初に入力を式として解釈しようとします。 ただし、コマンド呼び出しが検出されると、引数モードで解析が続行されます。

引数モードは、シェル環境でコマンドの引数とパラメーターを解析するように設計されています。 次のいずれかの構文を使用しない限り、すべての入力は展開可能な文字列として扱われます。

- ドル記号 ( `$` ) は変数参照を開始します (その後に有効な変数名が続く場合のみ)。それ以外の場合は、展開可能な文字列の一部として解釈されます。
- 引用符 ( `'` および `"` ) の開始文字列値
- かっこ ( `(` と `)` ) 区別新しい式です。
- 部分式演算子 ( `$(` ... `)` ) 区分埋め込み式。
- 中かっこ ( `{` と `}` ) 区別は、新しいスクリプトブロックを作成します。
- 最初のアットマーク ( `@` ) `@args` は、スプラッティング ()、配列 ()、 `@(1,2,3)` ハッシュテーブル () などの式の構文を開始し `@{a=1;b=2}` ます。
- コンマ ( `,` ) は、配列として渡されるリストを導入します。ただし、呼び出されるコマンドがネイティブアプリケーションである場合を除きます。この場合、拡張可能な文字列の一部として解釈されます。 最初、連続、または末尾のコンマはサポートされていません。

<!--
01234567890123456789012345678901234567890123456789012345678901234567890123456789
-->
埋め込み式の値は、文字列に変換されます。

次の表に、式モードおよび引数モードで処理される値の例と、それらの値の評価を示します。 変数の値がであることを前提として `a` `4` います。

|       例        |    モード    |      結果       |
| -------------------- | ---------- | ----------------- |
| `2`                  | 式 | 2 (整数)       |
| `` `2``              | Expression | "2" (コマンド)     |
| `echo 2`             | Expression | 2 (整数)       |
| `2+2`                | Expression | 4 (整数)       |
| `echo 2+2`           | 引数   | "2 + 2" (文字列)    |
| `echo(2+2)`          | Expression | 4 (整数)       |
| `$a`                 | Expression | 4 (整数)       |
| `echo $a`            | Expression | 4 (整数)       |
| `$a+2`               | Expression | 6 (整数)       |
| `echo $a+2`          | 引数   | 4 + 2 (文字列)      |
| `$-`                 | 引数   | "$-" (コマンド)    |
| `echo $-`            | 引数   | "$-" (文字列)     |
| `a$a`                | Expression | "a $ a" (コマンド)   |
| `echo a$a`           | 引数   | "a4" (文字列)     |
| `a'$a'`              | Expression | "a $ a" (コマンド)   |
| `echo a'$a'`         | 引数   | "a $ a" (文字列)    |
| `a"$a"`              | Expression | "a $ a" (コマンド)   |
| `echo a"$a"`         | 引数   | "a4" (文字列)     |
| `a$(2)`              | Expression | "a $ (2)" (コマンド) |
| `echo a$(2)`         | 引数   | "a2" (文字列)     |

すべてのトークンは、ブール値や文字列など、何らかの種類のオブジェクトとして解釈できます。 PowerShell は、式からオブジェクトの種類を特定しようとします。
オブジェクトの種類は、コマンドが想定するパラメーターの型と、引数を正しい型に変換する方法を PowerShell が認識しているかどうかによって異なります。 次の表に、式によって返される値に割り当てられる型の例をいくつか示します。

|       例          |    モード    |     結果      |
| ---------------------- | ---------- | --------------- |
| `Write-Output !1`      | 引数   | "! 1" (文字列)   |
| `Write-Output (!1)`    | expression | False (ブール値) |
| `Write-Output (2)`     | expression | 2 (整数)     |
| `Set-Variable AB A,B`  | 引数   | ' A '、' B ' (配列) |
| `CMD /CECHO A,B`       | 引数   | ' A, B ' (文字列)  |
| `CMD /CECHO $AB`       | expression | ' A '、' B ' (配列) |
| `CMD /CECHO :$AB`      | 引数   | ': A B ' (文字列) |

Powershell 3.0 で導入された解析の中止記号 () は、powershell `--%` コマンドまたは式として入力を解釈しないように powershell に指示します。

PowerShell で実行可能プログラムを呼び出す場合は、プログラムの引数の前にストップ解析のシンボルを配置します。 この手法は、誤って解釈されないようにエスケープ文字を使用するよりもはるかに簡単です。

ストップ解析シンボルが検出されると、PowerShell は行の残りの文字をリテラルとして扱います。 実行する唯一の解釈は、など、標準の Windows 表記を使用する環境変数の値を置き換えることです `%USERPROFILE%` 。

ストップ解析シンボルは、次の改行文字またはパイプライン文字まで有効です。 継続文字 () を使用して `` ` `` その効果を拡張したり、コマンド区切り記号 () を使用してその効果を終了したりすることはできません `;` 。

たとえば、次のコマンドは、 **Icacls** プログラムを呼び出します。

```powershell
icacls X:\VMS /grant Dom\HVAdmin:(CI)(OI)F
```

PowerShell 2.0 でこのコマンドを実行するには、エスケープ文字を使用して、PowerShell がかっこを誤って解釈できないようにする必要があります。

```powershell
icacls X:\VMS /grant Dom\HVAdmin:`(CI`)`(OI`)F
```

PowerShell 3.0 以降では、ストップ解析シンボルを使用できます。

```powershell
icacls X:\VMS --% /grant Dom\HVAdmin:(CI)(OI)F
```

PowerShell は、次のコマンド文字列を **Icacls** プログラムに送信します。

`X:\VMS /grant Dom\HVAdmin:(CI)(OI)F`

> [!NOTE]
> ストップ解析シンボルは、Windows プラットフォームでの使用のみを目的としています。

## <a name="see-also"></a>関連項目

[about_Command_Syntax](about_Command_Syntax.md)
