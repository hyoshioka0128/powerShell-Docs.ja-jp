---
description: 整数リテラルと実数リテラルは、どちらも型および乗数サフィックスを持つことができます。
Locale: en-US
ms.date: 04/09/2018
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_numeric_literals?view=powershell-6&WT.mc_id=ps-gethelp
schema: 2.0.0
title: 数値リテラルについて
ms.openlocfilehash: 62f00ae9f3643724808146134fd03b6f01c29bce
ms.sourcegitcommit: ae8b89e12c6fa2108075888dd6da92788d6c2888
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/21/2020
ms.locfileid: "93224688"
---
# <a name="about-numeric-literals"></a>数値リテラルについて

数値リテラルには、整数と実数の2種類があります。 どちらも、型と乗数のサフィックスを持つことができます。

## <a name="integer-literals"></a>整数リテラル

整数リテラルは、10進数または16進表記で記述できます。 16進数リテラルには、 `0x` 10 進数と区別するためのプレフィックスが付きます。

整数リテラルには、型サフィックスと乗数サフィックスを含めることができます。

| サフィックス |            説明             |          注意           |
| ------ | ------------------------------ | ----------------------- |
| ○      | 符号付きバイトデータ型          | PowerShell 6.2 で追加 |
| uy     | unsigned byte データ型        | PowerShell 6.2 で追加 |
| s      | short データ型                | PowerShell 6.2 で追加 |
| us     | unsigned short データ型       | PowerShell 6.2 で追加 |
| l      | long データ型                 |                         |
| u      | unsigned int または long データ型 | PowerShell 6.2 で追加 |
| ul     | unsigned long データ型        | PowerShell 6.2 で追加 |
| kb     | キロバイト乗数            |                         |
| mb     | メガバイト乗数            |                         |
| 8gb     | ギガバイト乗数            |                         |
| 単位     | テラバイト乗数            |                         |
| pb     | ペタバイト乗数            |                         |

整数リテラルの型は、その値、型のサフィックス、および数値乗数のサフィックスによって決定されます。

型サフィックスのない整数リテラルの場合:

- 値を型で表すことができる場合 `[int]` は。それが型である場合は。
- それ以外の場合、値を型で表すことができる場合は、それ以外の場合は `[long]` 型です。
- それ以外の場合、値を型で表すことができる場合は、それ以外の場合は `[decimal]` 型です。
- それ以外の場合は、型によって表され `[double]` ます。

型サフィックスを持つ整数リテラルの場合:

- 型のサフィックスがで、 `u` 値を型で表すことができる場合、 `[uint]` 型はになり `[uint]` ます。
- 型のサフィックスがで、 `u` 値を型で表すことができる場合、 `[ulong]` 型はになり `[ulong]` ます。
- 指定された型で値を表すことができる場合は、その型になります。
- それ以外の場合は、そのリテラルの形式が正しくありません。

## <a name="real-literals"></a>実数リテラル

実際のリテラルは、10進表記でのみ記述できます。 この表記法では、小数点の後に指数部を使用した小数値と指数表記を含めることができます。

指数部には、"e" の後に省略可能な符号 (+/-) と指数を表す数値が含まれます。 たとえば、リテラル値は `1e2` 数値100と同じです。

実際のリテラルは、型サフィックスと乗数サフィックスを持つことができます。

| サフィックス |       説明       |
| ------ | ------------------- |
| d      | decimal データ型   |
| kb     | キロバイト乗数 |
| mb     | メガバイト乗数 |
| 8gb     | ギガバイト乗数 |
| 単位     | テラバイト乗数 |
| pb     | ペタバイト乗数 |

実数リテラルには、double と decimal の2種類があります。 これらは、それぞれ、decimal 型のサフィックスによって、個別に存在するかどうかが示されます。 PowerShell では、値のリテラル表現はサポートされていません `[float]` 。 Double 実数リテラルには型があり `[double]` ます。 10進数の実数リテラルには型があり `[decimal]` ます。
10進数の実数リテラルの小数部の末尾の0は有意です。

実数リテラルの指数部の数字の値が、 `[double]` サポートされる最小値よりも小さい場合、その `[double]` 実数リテラルの値は0になります。 実数リテラルの指数部の数字の値が、 `[decimal]` サポートされている最小値よりも小さい場合、そのリテラルの形式が正しくありません。 または実数リテラルの指数部の数字の値 `[double]` `[decimal]` が、サポートされている最大値を超えている場合、そのリテラルの形式が正しくありません。

> [!NOTE]
> この構文では、2つの実数リテラルに long 型のサフィックスを付けることができます。
> PowerShell では、このケースは、値が型で表される整数リテラルとして扱われ `[long]` ます。 この機能は、以前のバージョンの PowerShell との下位互換性のために残されています。 ただし、プログラマはこの形式の整数リテラルを使用しないことをお勧めします。これは、リテラルの実際の値を簡単に隠すことができるためです。 たとえば、の値 `1.2L` が1で、値が `1.2345e1L` 12 で、 `1.2345e-5L` 値が0である場合、そのいずれもすぐにはわかりません。

## <a name="numeric-multipliers"></a>数値乗数

便宜上、整数と実数のリテラルには数値乗数を含めることができます。これは、一般的に使用される2の累乗の1つを示します。 数値の乗数は、大文字または小文字の任意の組み合わせで記述できます。

乗数サフィックスは、、、およびの各型サフィックスと組み合わせて使用でき `u` `ul` `l` ます。

### <a name="multiplier-examples"></a>乗数の例

```
PS> 1kb
1024

PS> 1.30Dmb
1363148.80

PS> 0x10Gb
17179869184

PS> 1.4e23tb
1.5393162788864E+35

PS> 0x12Lpb
20266198323167232
```

## <a name="numeric-type-accelerators"></a>数値型アクセラレータ

PowerShell では、次の種類のアクセラレータがサポートされています。

| アクセラレータ |         注意         |           説明            |
| ----------- | -------------------- | -------------------------------- |
| `[byte]`    |                      | バイト (符号なし)                  |
| `[sbyte]`   |                      | バイト (符号付き)                    |
| `[Int16]`   |                      | 16 ビット整数                   |
| `[short]`   | の別名 `[int16]`  | 16 ビット整数                   |
| `[UInt16]`  |                      | 16ビット整数 (符号なし)        |
| `[ushort]`  | の別名 `[uint16]` | 16ビット整数 (符号なし)        |
| `[Int32]`   |                      | 32-bit integer                   |
| `[int]`     | の別名 `[int32]`  | 32-bit integer                   |
| `[UInt32]`  |                      | 32ビット整数 (符号なし)        |
| `[uint]`    | の別名 `[uint32]` | 32ビット整数 (符号なし)        |
| `[Int64]`   |                      | 64 ビット整数                   |
| `[long]`    | の別名 `[int64]`  | 64 ビット整数                   |
| `[UInt64]`  |                      | 64ビット整数 (符号なし)        |
| `[ulong]`   | の別名 `[uint64]` | 64ビット整数 (符号なし)        |
| `[bigint]`  |                      | 「 [BigInteger Struct][bigint] 」を参照してください。  |
| `[single]`  |                      | 単精度浮動小数点  |
| `[float]`   | の別名 `[single]` | 単精度浮動小数点  |
| `[double]`  |                      | 倍精度浮動小数点  |
| `[decimal]` |                      | 128ビット浮動小数点           |

> [!NOTE]
> PowerShell 6.2 では、、、、の各型アクセラレータが追加されました。 `[short]` `[ushort]` `[uint]` `[ulong]`

### <a name="working-with-other-numeric-types"></a>他の数値型の使用

他の数値型を操作するには、型アクセラレータを使用する必要があります。これは、いくつかの問題がないことを示します。 たとえば、高い整数値は、他の型にキャストされる前に、常に double として解析されます。

```
PS> [bigint]111111111111111111111111111111111111111111111111111111
111111111111111100905595216014112456735339620444667904
```

値は、最初は double として解析され、上位の範囲の有効桁数が失われます。
この問題を回避するには、値を文字列として入力し、変換します。

```
PS> [bigint]'111111111111111111111111111111111111111111111111111111'
111111111111111111111111111111111111111111111111111111
```

## <a name="examples"></a>例

次の表は、数値リテラルの例をいくつか示し、その型と値を示しています。

|  Number  |  Type   |    値     |
| -------: | ------- | -----------: |
|      100 | Int32   |          100 |
|     100D | Decimal (10 進数型) |          100 |
|     100l | Int64   |          100 |
|    100uL | UInt64  |          100 |
|    100us | UInt16  |          100 |
|    100uy | Byte    |          100 |
|     100y | SByte   |          100 |
|      1e2 | Double  |          100 |
|     e2 | Double  |          100 |
|    0x1e2 | Int32   |          482 |
|   0x1e2L | Int64   |          482 |
|   0x1e2D | Int32   |         7725 |
|     482D | Decimal (10 進数型) |          482 |
|    48 gb | Int64   | 517543559168 |
| 0x1e2lgb | Int64   | 517543559168 |

### <a name="commands-that-look-like-numeric-literals"></a>数値リテラルのようなコマンド

数値リテラルのようなコマンドは、呼び出し演算子 () を使用して実行する必要があり `&` ます。それ以外の場合は、関連付けられている型の数値として解釈されます。

### <a name="access-properties-and-methods-of-numeric-objects"></a>数値オブジェクトのプロパティとメソッドへのアクセス

数値リテラルのメンバーにアクセスするには、リテラルをかっこで囲む必要がある場合があります。

- リテラルに小数点がありません
- リテラルの小数点の後に数字がありません。
- リテラルにサフィックスがありません

たとえば、次の例では失敗します。

```
PS> 2.GetType().Name
At line:1 char:11
+ 2.GetType().Name
+           ~
An expression was expected after '('.
+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
+ FullyQualifiedErrorId : ExpectedExpression
```

次の例は動作します。

```
PS> 2uL.GetType().Name
UInt64
PS> 1.234.GetType().Name
Double
PS> (2).GetType().Name
Int32
```

最初の2つの例では、リテラル値をかっこで囲まずに使用します。これは、PowerShell パーサーが数値リテラルの終了位置と **GetType** メソッドの開始位置を判別できるためです。

<!-- reference links -->
[bigint]: /dotnet/api/system.numerics.biginteger?view=netcore-2.2
