---
description: PowerShell で算術演算を実行する演算子について説明します。
keywords: powershell,コマンドレット
Locale: en-US
ms.date: 10/08/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arithmetic_operators?view=powershell-5.1&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Arithmetic_Operators
ms.openlocfilehash: 96ca73a613c30e844fb19de29bf005480c5703d9
ms.sourcegitcommit: f874dc1d4236e06a3df195d179f59e0a7d9f8436
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/13/2020
ms.locfileid: "93222832"
---
# <a name="about-arithmetic-operators"></a>算術演算子について

## <a name="short-description"></a>概要
PowerShell で算術演算を実行する演算子について説明します。

## <a name="long-description"></a>詳細説明

算術演算子は数値を計算します。 1つまたは複数の算術演算子を使用して、値の加算、減算、乗算、除算を行ったり、除算演算の剰余 (剰余) を計算したりすることができます。

さらに、加算演算子 ( `+` ) と乗算演算子 () は、 `*` 文字列、配列、およびハッシュテーブルにも作用します。 加算演算子は、入力を連結します。 乗算演算子は、入力の複数のコピーを返します。 算術ステートメントでは、オブジェクトの種類を混在させることもできます。 ステートメントの評価に使用されるメソッドは、式の中で最も左にあるオブジェクトの型によって決まります。

PowerShell 2.0 以降では、すべての算術演算子が64ビットの数値に対して機能します。

PowerShell 3.0 以降では、 `-shr` `-shl` powershell でビットごとの算術演算をサポートするために、(shift + right) と (shift + ←) が追加されます。

PowerShell では、次の算術演算子がサポートされています。

|演算子|説明                       |例                      |
|--------|----------------------------------|-----------------------------|
| +      |整数を加算します。を連結し       |`6 + 2`                      |
|        |文字列、配列、およびハッシュテーブル。 |`"file" + "name"`            |
|        |                                  |`@(1, "one") + @(2.0, "two")`|
|        |                                  |`@{"one" = 1} + @{"two" = 2}`|
| -      |ある値を別の値から減算する  |`6 - 2`                      |
|        |value                             |                             |
| -      |数値を負の数にします  |`-6`                         |
|        |                                  |`(Get-Date).AddDays(-1)`     |
| *      |数値の乗算または文字列のコピー  |`6 * 2`                      |
|        |指定した数の配列と配列   |`@("!") * 4`                 |
|        |回です。                         |`"!" * 3`                    |
| /      |2 つの値を除算します。               |`6 / 2`                      |
| %      |剰余-の剰余を返します。|`7 % 2`                      |
|        |除算演算。             |                             |
|-帯域   |ビット演算子 AND                       |`5 -band 3`                  |
|-bnot   |ビットごとの NOT                       |`-bnot 5`                    |
|-bor    |ビットごとの OR                        |`5 -bor 0x03`                |
|-bxor   |ビットごとの XOR                       |`5 -bxor 3`                  |
|-shl    |ビットを左にシフトする           |`102 -shl 2`                 |
|-shr    |ビットを右にシフトする          |`102 -shr 2`                 |

ビットごとの演算子は、整数型でのみ機能します。

## <a name="operator-precedence"></a>演算子の優先順位

PowerShell は、次の順序で算術演算子を処理します。

|優先順位|演算子          |説明                            |
|----------|------------------|---------------------------------------|
|1         | `()`             |かっこ                            |
|2         | `-`              |負の数または単項演算子の場合|
|3         | `*`, `/`, `%`    |乗算と除算の場合        |
|4         | `+`, `-`         |加算と減算の場合           |
|5         | `-band`, `-bnot` |ビットごとの演算の場合                 |
|5         | `-bor`, `-bxor`  |ビットごとの演算の場合                 |
|5         | `-shr`, `-shl`   |ビットごとの演算の場合                 |

PowerShell は、優先順位の規則に従って、式を左から右に処理します。 次の例は、優先順位規則の効果を示しています。

|正規表現 |結果|
|-----------|------|
|`3+6/3*4`  |`11`  |
|`3+6/(3*4)`|`3.5` |
|`(3+6)/3*4`|`12`  |

PowerShell が式を評価する順序は、使用した他のプログラミング言語とスクリプト言語とは異なる場合があります。 次の例は、複雑な代入ステートメントを示しています。

```powershell
$a = 0
$b = @(1,2)
$c = @(-1,-2)

$b[$a] = $c[$a++]
```

この例では、式 `$a++` はの前に評価され `$b[$a]` ます。
を評価すると、 `$a++` ステートメントで使用された後のの値が変更され `$a` `$c[$a++]` ます。ただし、では、が使用され `$b[$a]` ます。 の変数はではなくになります。したがって、ステートメントでは、では `$a` `$b[$a]` `1` `0` なく、に値が割り当てられ `$b[1]` `$b[0]` ます。

上記のコードは、次のコードに相当します。

```powershell
$a = 0
$b = @(1,2)
$c = @(-1,-2)

$tmp = $c[$a]
$a = $a + 1
$b[$a] = $tmp
```

## <a name="division-and-rounding"></a>除算と丸め

除算演算の商が整数である場合、PowerShell は値を最も近い整数に丸めます。 値がの場合は `.5` 、最も近い偶数の整数に丸められます。

次の例は、最も近い偶数の整数に丸めた場合の効果を示しています。

|正規表現      |結果|
|----------------|------|
|`[int]( 5 / 2 )`|`2`   |
|`[int]( 7 / 2 )`|`4`   |

**_5/2_ = 2.5** が **2** に丸められていることに注目してください。 しかし、 **_7/2_ = 3.5** は **4** に丸められます。

クラスを使用すると、 `[Math]` 異なる丸め動作を取得できます。

|                          正規表現                          | 結果 |
| ------------------------------------------------------------ | ------ |
| `[int][Math]::Round(5 / 2,[MidpointRounding]::AwayFromZero)` | `3`    |
| `[int][Math]::Ceiling(5 / 2)`                                | `3`    |
| `[int][Math]::Floor(5 / 2)`                                  | `2`    |

詳細については、「 [Math. Round](/dotnet/api/system.math.round) メソッド」を参照してください。

## <a name="adding-and-multiplying-non-numeric-types"></a>数値以外の型の加算と乗算

数値、文字列、配列、およびハッシュテーブルを追加できます。 また、数値、文字列、および配列を乗算することもできます。 ただし、ハッシュテーブルを乗算することはできません。

文字列、配列、またはハッシュテーブルを追加すると、要素が連結されます。 配列、ハッシュテーブルなどのコレクションを連結すると、両方のコレクションのオブジェクトを含む新しいオブジェクトが作成されます。 同じキーを持つハッシュテーブルを連結しようとすると、操作は失敗します。

たとえば、次のコマンドでは、2つの配列を作成して追加します。

```powershell
$a = 1,2,3
$b = "A","B","C"
$a + $b
```

```output
1
2
3
A
B
C
```

また、さまざまな型のオブジェクトに対して算術演算を実行することもできます。
PowerShell が実行する操作は、操作の左端のオブジェクトの Microsoft .NET Framework 型によって決まります。 PowerShell は、操作内のすべてのオブジェクトを、最初のオブジェクトの .NET Framework 型に変換しようとします。 オブジェクトの変換に成功した場合は、最初のオブジェクトの .NET Framework 型に適した操作を実行します。 オブジェクトの変換に失敗した場合、操作は失敗します。

加算演算子と乗算演算子の使用例を次に示します。異なる種類のオブジェクトを含む操作。 次の場合を想定し `$array = 1,2,3` ます。

|正規表現       |結果                 |
|-----------------|-----------------------|
|`"file" + 16`    |`file16`               |
|`$array + 16`    |`1`,`2`,`3`,`16`       |
|`$array + "file"`|`1`,`2`,`3`,`file`     |
|`$array * 2`     |`1`,`2`,`3`,`1`,`2`,`3`|
|`"file" * 3`     |`filefilefile`         |

ステートメントの評価に使用されるメソッドは左端のオブジェクトによって決定されるため、PowerShell での加算と乗算は厳密には可換ではありません。 たとえば、は常にと等しいとは限りません。また、は常にと同じではありませ `(a + b)` `(b + a)` `(ab)` ん `(ba)` 。

次の例は、この原則を示しています。

|正規表現   |結果                                               |
|-------------|-----------------------------------------------------|
|`"file" + 16`|`file16`                                             |
|`16 + "file"`|`Cannot convert value "file" to type "System.Int32".`|
|             |`Error: "Input string was not in a correct format."` |
|             |`At line:1 char:1`                                   |
|             |+ 16 + "ファイル"                                       |

ハッシュテーブルのケースは少し異なります。 ハッシュテーブルを別のハッシュテーブルに追加することができます。ただし、追加されたハッシュテーブルに重複するキーはありません。

次の例では、ハッシュテーブルを相互に追加する方法を示します。

```powershell
$hash1 = @{a=1; b=2; c=3}
$hash2 = @{c1="Server01"; c2="Server02"}
$hash1 + $hash2
```

```output
Name                           Value
----                           -----
c2                             Server02
a                              1
b                              2
c1                             Server01
c                              3
```

次の例では、いずれかのキーが両方のハッシュテーブルで重複しているため、エラーがスローされます。

```powershell
$hash1 = @{a=1; b=2; c=3}
$hash2 = @{c1="Server01"; c="Server02"}
$hash1 + $hash2
```

```output
Item has already been added. Key in dictionary: 'c'  Key being added: 'c'
At line:3 char:1
+ $hash1 + $hash2
+ ~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], ArgumentException
    + FullyQualifiedErrorId : System.ArgumentException
```

また、ハッシュテーブルを配列に追加することもできます。また、ハッシュテーブル全体が配列内の項目になります。

```powershell
$array1 = @(0, "Hello World", [datetime]::Now)
$hash1 = @{a=1; b=2}
$array2 = $array1 + $hash1
$array2
```

```output
0
Hello World

Monday, June 12, 2017 3:05:46 PM

Key   : a
Value : 1
Name  : a

Key   : b
Value : 2
Name  : b
```

ただし、他の型をハッシュテーブルに追加することはできません。

```powershell
$hash1 + 2
```

```output
A hash table can only be added to another hash table.
At line:3 char:1
+ $hash1 + 2
```

加算演算子は非常に便利ですが、代入演算子を使用して、ハッシュテーブルとハッシュ配列に要素を追加します。 詳細については、「 [about_assignment_operators](about_Assignment_Operators.md)」を参照してください。 次の例では、代入演算子を使用して、 `+=` 配列に項目を追加しています。

```powershell
$array = @()
(0..9).foreach{ $array += $_ }
$array
```

```output
0
1
2
```

## <a name="type-conversion-to-accommodate-result"></a>結果に対応する型変換

PowerShell では、有効桁数を失うことなく、結果を最もよく表現する .NET Framework の数値型が自動的に選択されます。 次に例を示します。

```powershell
2 + 3.1

(2). GetType().FullName
(2 + 3.1).GetType().FullName
```

```output
5.1
System.Int32
System.Double
```

演算の結果が型に対して大きすぎる場合は、次の例のように、結果を格納できるように結果の型が拡張されます。

```powershell
(512MB).GetType().FullName
(512MB * 512MB).GetType().FullName
```

```output
System.Int32
System.Double
```

結果の型は、必ずしもオペランドの1つと同じであるとは限りません。 次の例では、負の値を符号なし整数にキャストすることはできません。また、符号なし整数が大きすぎてにキャストできません `Int32` 。

```powershell
([int32]::minvalue + [uint32]::maxvalue).gettype().fullname
```

```output
System.Int64
```

この例では、は `Int64` 両方の型に対応できます。

この `System.Decimal` 型は例外です。 いずれかのオペランドが10進数型の場合、結果は10進数型になります。 結果が Decimal 型に対して大きすぎる場合、Double にキャストされません。 代わりに、エラーが発生します。

|正規表現               |結果                                         |
|-------------------------|-----------------------------------------------|
|`[Decimal]::maxvalue`    |`79228162514264337593543950335`                |
|`[Decimal]::maxvalue + 1`|`Value was either too large or too small for a`|
|                         |`Decimal.`                                     |

## <a name="arithmetic-operators-and-variables"></a>算術演算子と変数

変数と共に算術演算子を使用することもできます。 演算子は、変数の値に対して機能します。 次の例では、変数で算術演算子を使用する方法を示します。

| 正規表現                                    |結果      |
|-----------------------------------------------|------------|
|`$intA = 6`<br/>`$intB = 4`<br/>`$intA + $intB`|`10`        |
|`$a = "Power"`<br/>`$b = "Shell"`<br/>`$a + $b`|`PowerShell`|

## <a name="arithmetic-operators-and-commands"></a>算術演算子とコマンド

通常、数値、文字列、および配列を含む式では、算術演算子を使用します。 ただし、コマンドが返すオブジェクトと、それらのオブジェクトのプロパティを使用して、算術演算子を使用することもできます。

次の例は、PowerShell コマンドを使用して式で算術演算子を使用する方法を示しています。

```powershell
(get-date) + (new-timespan -day 1)
```

かっこ演算子は、 `get-date` コマンドレットとコマンドレットの式の評価を、この順序で強制的に実行し `new-timespan -day 1` ます。 その後、両方の結果が演算子を使用して追加され `+` ます。

```powershell
Get-Process | Where-Object { ($_.ws * 2) -gt 50mb }
```

```output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
   1896      39    50968      30620   264 1,572.55   1104 explorer
  12802      78   188468      81032   753 3,676.39   5676 OUTLOOK
    660       9    36168      26956   143    12.20    988 PowerShell
    561      14     6592      28144   110 1,010.09    496 services
   3476      80    34664      26092   234 ...45.69    876 svchost
    967      30    58804      59496   416   930.97   2508 WINWORD
```

上の式では、各プロセスの作業領域 () にを乗算し、結果を比較して、より `$_.ws` `2` `50mb` 大きいかどうかを確認します。

## <a name="bitwise-operators"></a>ビット処理演算子

PowerShell では、ビットごとの and ( `-bAnd` )、包括的および排他的のビットごとの or 演算子 ( `-bOr` and)、 `-bXor` およびビットごとの-not () を含む、標準のビットごとの演算子をサポートしてい `-bNot` ます。

PowerShell 2.0 以降では、すべてのビットごとの演算子は64ビット整数で動作します。

PowerShell 3.0 以降では、 `-shr` `-shl` powershell でビットごとの算術演算をサポートするために、(shift + right) と (shift + ←) が導入されています。

PowerShell では、次のビットごとの演算子がサポートされています。

| 演算子 | 説明            | 式   | 結果 |
| -------- | ---------------------- | ------------ | ------ |
| `-band`  | ビット演算子 AND            | `10 -band 3` | 2      |
| `-bor`   | ビットごとの OR (を含む) | `10 -bor 3`  | 11     |
| `-bxor`  | ビットごとの OR (排他的) | `10 -bxor 3` | 9      |
| `-bnot`  | ビットごとの NOT            | `-bNot 10`   | -11    |
| `-shl`   | 左シフト             | `102 -shl 2` | 408    |
| `-shr`   | 右シフト            | `102 -shr 1` | 51     |

ビットごとの演算子は、値のバイナリ形式に対して動作します。 たとえば、10進数のビット構造は00001010で (1 バイトに基づいて)、数値3のビット構造は00000011です。 ビットごとの演算子を使用して10を3と比較すると、各バイトの個々のビットが比較されます。

ビットごとの AND 演算では、両方の入力ビットが1の場合にのみ、結果として得られるビットが1に設定されます。

```
1010      (10)
0011      ( 3)
--------------  bAND
0010      ( 2)
```

ビットごとの OR (包括) 演算では、いずれかまたは両方の入力ビットが1の場合、結果のビットは1に設定されます。 両方の入力ビットが0に設定されている場合にのみ、結果のビットが0に設定されます。

```
1010      (10)
0011      ( 3)
--------------  bOR (inclusive)
1011      (11)
```

ビットごとの OR (排他的) 演算では、1つの入力ビットが1の場合にのみ、結果として得られるビットが1に設定されます。

```
1010      (10)
0011      ( 3)
--------------  bXOR (exclusive)
1001      ( 9)
```

ビットごとの NOT 演算子は、値のバイナリ補数を生成する単項演算子です。 ビット1を0に設定し、ビット0を1に設定します。

たとえば、0のバイナリ補数は-1、最大符号なし整数 (0xffffffff)、および-1 のバイナリ補数は0です。

```powershell
-bNot 10
```

```Output
-11
```

```
0000 0000 0000 1010  (10)
------------------------- bNOT
1111 1111 1111 0101  (-11, xfffffff5)
```

ビットごとのシフト左演算では、すべてのビットが "n" の位置を左に移動します。 "n" は右のオペランドの値です。 1つの場所にゼロが挿入されます。

左オペランドが整数 (32 ビット) 値の場合、右オペランドの下位5ビットによって左オペランドのビット数が決定されます。

左側のオペランドが Long (64 ビット) 値の場合、右オペランドの下位6ビットによって左オペランドのビット数が決定されます。

|正規表現 |結果|バイナリの結果|
|-----------|------|-------------|
|`21 -shl 0`|21    |0001 0101    |
|`21 -shl 1`|42    |0010 1010    |
|`21 -shl 2`|84    |0101 0100    |

ビットごとのシフト右演算では、すべてのビットが右側のオペランドによって指定されている "n" を右に移動します。 右に正または符号なしの値をシフトすると、シフト右の演算子 (-shr) によって左端にゼロが挿入されます。

左オペランドが整数 (32 ビット) 値の場合、右オペランドの下位5ビットによって左オペランドのビット数が決定されます。

左側のオペランドが Long (64 ビット) 値の場合、右オペランドの下位6ビットによって左オペランドのビット数が決定されます。

|正規表現              |結果      |Binary     |Hex         |
|------------------------|------------|-----------|------------|
|`21 -shr 0`             | 21         | 0001 0101 | 0x15       |
|`21 -shr 1`             | 10         | 0000 1010 | 0x0A       |
|`21 -shr 2`             | 5          | 0000 0101 | 0x05       |
|`21 -shr 31`            | 0          | 0000 0000 | 0x00       |
|`21 -shr 32`            | 21         | 0001 0101 | 0x15       |
|`21 -shr 64`            | 21         | 0001 0101 | 0x15       |
|`21 -shr 65`            | 10         | 0000 1010 | 0x0A       |
|`21 -shr 66`            | 5          | 0000 0101 | 0x05       |
|`[int]::MaxValue -shr 1`| 1073741823 |           | 0x3FFFFFFF |
|`[int]::MinValue -shr 1`| -1073741824|           | 0xC0000000 |
|`-1 -shr 1`             | -1         |           | ~ |

## <a name="see-also"></a>関連項目

- [about_arrays](about_Arrays.md)
- [about_assignment_operators](about_Assignment_Operators.md)
- [about_comparison_operators](about_Comparison_Operators.md)
- [about_hash_tables](about_Hash_Tables.md)
- [about_operators](about_Operators.md)
- [about_variables](about_Variables.md)
- [Get-Date](xref:Microsoft.PowerShell.Utility.Get-Date)
- [New-TimeSpan](xref:Microsoft.PowerShell.Utility.New-TimeSpan)
